#include "Parser.h"

/**
 * @brief Конструирует объект Parser с заданным вектором токенов.
 *
 * Этот конструктор инициализирует экземпляр Parser, принимая владение переданным
 * QVector<Token> для последующих операций парсинга.
 *
 * @param tokens QVector объектов Token, представляющий лексические токены,
 *               которые будут анализироваться парсером.
 */
Parser::Parser(const QVector<Token>& tokens) : tokens(tokens) {}

/**
 * @brief Разбирает входные токены и формирует абстрактное синтаксическое дерево (AST).
 *
 * Этот метод служит основным входом для процесса парсинга. Он координирует
 * разбор, вызывая соответствующие вспомогательные методы для анализа последовательности токенов
 * и построения соответствующего представления AST.
 *
 * @return Умный указатель на корневой ASTNode созданного абстрактного синтаксического дерева.
 *         Возвращает nullptr, если разбор завершился неудачно или не удалось построить синтаксическое дерево.
 */
std::shared_ptr<ASTNode> Parser::parse() { return parseExpression(); }

/**
 * @brief Разбирает выражение из токенов и строит соответствующее AST.
 *
 * Этот метод обрабатывает токены, представляющие выражение, формируя абстрактное синтаксическое дерево (AST)
 * для операций сложения («+») и вычитания («-»). Поддерживает вычисление выражений с левосторонней
 * ассоциативностью и формирует дерево бинарных операций из отдельных членов.
 *
 * @return Умный указатель на корень AST, представляющего разобранное выражение.
 */
std::shared_ptr<ASTNode> Parser::parseExpression() {
    auto left = parseTerm();
    while (peek().type == TOKEN_OP && (peek().value == "+" || peek().value == "-")) {
        QString op = advance().value;
        auto right = parseTerm();
        left = std::make_shared<BinOpNode>(left, op, right);
    }
    return left;
}

/**
 * @brief Разбирает терм в последовательности токенов и строит соответствующий узел AST.
 *
 * Этот метод разбирает терм, определённый как последовательность выражений-степеней,
 * объединённых операторами умножения (*), деления (/), целочисленного деления (//) и остатка от деления (%).
 * Для каждого встреченного оператора формируется узел бинарной операции, что позволяет построить
 * левосторонне ассоциативное представление выражения.
 *
 * @return Умный указатель на корневой узел AST, представляющий разобранный терм.
 *         Если терм не может быть разобран, поведение не определено.
 */
std::shared_ptr<ASTNode> Parser::parseTerm() {
    auto left = parsePower();
    while (peek().type == TOKEN_OP &&
        (peek().value == "*" || peek().value == "/" || peek().value == "//" || peek().value == "%")) {
        QString op = advance().value;
        auto right = parsePower();
        left = std::make_shared<BinOpNode>(left, op, right);
    }
    return left;
}

/**
 * @brief Разбирает выражение возведения в степень в потоке входных токенов.
 *
 * Этот метод обрабатывает выражения с оператором возведения в степень ("**"),
 * учитывая соответствующие правила ассоциативности и приоритетов. Рекурсивно строит
 * узлы абстрактного синтаксического дерева (AST), представляющие такие операции. Если
 * оператор "**" не встречается, метод передаёт управление разбору
 * отдельных факторов.
 *
 * @return Умный указатель на корневой узел разобранного выражения, который
 *         может быть либо отдельным фактором, либо узлом бинарной операции
 *         возведения в степень.
 */
std::shared_ptr<ASTNode> Parser::parsePower()
{
    auto left = parseFactor();
    if (peek().type == TOKEN_OP && peek().value == "**")
    {
        QString op = advance().value;
        auto right = parsePower();
        return std::make_shared<BinOpNode>(left, op, right);
    }
    return left;
}

/**
 * @brief Разбирает фактор выражения и создаёт соответствующий узел AST.
 *
 * Этот метод обрабатывает числовые литералы и подвыражения в скобках.
 * Если встречается числовой литерал, создаётся `NumberNode`.
 * Если встречается подвыражение в скобках, рекурсивно разбирает выражение
 * внутри скобок и проверяет корректное закрытие скобкой.
 * Бросает исключение, если встречается неожиданный токен.
 *
 * @return Умный указатель на получившийся `ASTNode`, представляющий разобранный фактор,
 *         либо `nullptr`, если достигнут конец ввода (`TOKEN_EOF`).
 *
 * @throws std::runtime_error В случае неожиданного токена или
 *         отсутствия закрывающей скобки в подвыражении в скобках.
 */
std::shared_ptr<ASTNode> Parser::parseFactor() {
    Token token = peek();
    if (token.type == TOKEN_EOF) {
        return nullptr;
    }

    if (token.type == TOKEN_NUMBER) {
        advance();
        auto num = std::make_shared<NumberNode>();
        num->value = token.value.toDouble();
        return num;
    }
    if (token.type == TOKEN_OP && token.value == "(") {
        advance();
        auto expr = parseExpression();
        if (peek().type == TOKEN_OP || peek().value == ")") {
            advance();
        }
        else {
            throw std::runtime_error("Expected ')'");
        }
        return expr;
    }
    throw std::runtime_error("Unexpected token: \"" + token.value.toStdString() + "\"");
}

/**
 * @brief Получает текущий токен в потоке токенов, не сдвигая позицию.
 *
 * Этот метод возвращает токен на текущей позиции в процессе разбора.
 * Если достигнут конец потока токенов, возвращается специальный токен конца файла (EOF).
 *
 * @return Текущий токен, если позиция в потоке допустима; иначе токен типа TOKEN_EOF.
 */
Token Parser::peek() const { return (current < tokens.size()) ? tokens[current] : Token(TOKEN_EOF, "", 0); }

/**
 * @brief Продвигает парсер к следующему токену и возвращает текущий токен.
 *
 * Этот метод перемещает указатель текущего токена вперёд, если доступны ещё токены.
 * Если указатель выходит за пределы имеющихся токенов, возвращается токен с типом TOKEN_EOF.
 *
 * @return Текущий Token до продвижения. Если достигнут конец потока токенов,
 *         возвращается токен TOKEN_EOF.
 */
Token Parser::advance() { return (current < tokens.size()) ? tokens[current++] : Token(TOKEN_EOF, "", 0); }